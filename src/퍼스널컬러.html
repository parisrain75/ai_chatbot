<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê·€ì—¬ìš´ í¼ìŠ¤ë„ ì»¬ëŸ¬ ì°¾ê¸° ğŸ’– (Canvas)</title>
    <style>
        /* CSS: ìº”ë²„ìŠ¤ ì»¨í…Œì´ë„ˆì™€ ë°°ê²½ ìŠ¤íƒ€ì¼ */
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f7f3f3;
            color: #4a4a4a;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden; 
        }

        .canvas-container {
            background-color: #ffffff;
            border-radius: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            position: relative;
            /* ë°˜ì‘í˜• ì²˜ë¦¬ë¥¼ ìœ„í•´ ìµœëŒ€ ë„ˆë¹„ ì„¤ì • */
            width: 90%;
            max-width: 500px;
            aspect-ratio: 1 / 1.3; /* ë„ˆë¹„ ëŒ€ë¹„ ë†’ì´ ë¹„ìœ¨ */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* ë¡œë”© ìŠ¤í”¼ë„ˆ (JS ë¡œì§ì´ ë³µì¡í•  ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ë‚¨ê²¨ë‘ ) */
        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 4px solid #f3f3f3; 
            border-top: 4px solid #ff9aa2; 
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: none; 
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
    </style>
</head>
<body>

<div class="canvas-container">
    <canvas id="personalColorCanvas"></canvas>
    <div class="loading-spinner" id="loadingSpinner"></div>
</div>

<script>
    const canvas = document.getElementById('personalColorCanvas');
    const ctx = canvas.getContext('2d');

    // Canvas í•´ìƒë„ ë° í¬ê¸° ë³€ìˆ˜
    let dpi = window.devicePixelRatio || 1;
    let canvasWidth, canvasHeight;
    let scaleFactor; // DPI ë° í¬ê¸°ì— ë”°ë¥¸ ìŠ¤ì¼€ì¼ íŒ©í„°

    // UI ìƒíƒœ ê´€ë¦¬
    let currentQuestionIndex = 0;
    let warmScore = 0;
    let isQuizActive = true;
    let mouseX = 0;
    let mouseY = 0;

    // ìƒ‰ìƒ íŒ”ë ˆíŠ¸
    const colors = {
        primary: '#ff9aa2', // ê·€ì—¬ìš´ í•‘í¬
        secondary: '#ffb7b2', // ì—°í•œ í•‘í¬
        textColor: '#4a4a4a',
        buttonNormal: '#ff9aa2',
        buttonHover: '#e0838b',
        buttonText: '#ffffff',
        boxBorder: '#ffb7b2',
        shadow: 'rgba(0, 0, 0, 0.15)'
    };

    // í…ŒìŠ¤íŠ¸ ë°ì´í„°
    const questions = [
        {
            q: "ì„ í˜¸í•˜ëŠ” ì•¡ì„¸ì„œë¦¬ ìƒ‰ìƒì€?",
            options: [
                { text: "ê³¨ë“œë‚˜ ë”°ëœ»í•œ ë¡œì¦ˆ ê³¨ë“œ", value: 5 }, 
                { text: "ì‹¤ë²„ë‚˜ ì°¨ê°€ìš´ í”Œë˜í‹°ë„˜", value: 1 }
            ],
            image: "ğŸ’"
        },
        {
            q: "í‰ì†Œ ì¦ê²¨ ì…ëŠ” ì˜·ì˜ í†¤ì€?",
            options: [
                { text: "ì•„ì´ë³´ë¦¬, ë² ì´ì§€ ë“± ë”°ëœ»í•œ ìƒ‰ê°", value: 5 },
                { text: "ìˆœë°±ìƒ‰, ë¸”ë™ ë“± ì„ ëª…í•œ ìƒ‰ê°", value: 1 }
            ],
            image: "ğŸ‘š"
        },
        {
            q: "í”¼ë¶€ í˜ˆê´€ì„ ë³´ë©´ ì–´ë–¤ ìƒ‰ì´ ì£¼ë¥¼ ì´ë£¨ë‚˜ìš”? (ì†ëª© ì•ˆìª½)",
            options: [
                { text: "ë…¹ìƒ‰ ë¹›ì´ ë” ë§ì´ ë³´ì—¬ìš”", value: 5 },
                { text: "íŒŒë€ìƒ‰ ë˜ëŠ” ë³´ë¼ìƒ‰ ë¹›ì´ ë” ë§ì´ ë³´ì—¬ìš”", value: 1 }
            ],
            image: "âœ‹"
        },
        {
            q: "ì„ í˜¸í•˜ëŠ” ë¦½ìŠ¤í‹±/ë¸”ëŸ¬ì…” ìƒ‰ìƒì€?",
            options: [
                { text: "ì½”ë„, í”¼ì¹˜, ì˜¤ë Œì§€ ê³„ì—´", value: 5 },
                { text: "ë§ˆì  íƒ€, í‘¸ì‹œì•„, ë² ë¦¬ ê³„ì—´", value: 1 }
            ],
            image: "ğŸ’„"
        },
        {
            q: "ì—¼ìƒ‰ì„ í•œë‹¤ë©´ ì–´ë–¤ ê³„ì—´ì„ ì„ íƒí• ê¹Œìš”?",
            options: [
                { text: "ë ˆë“œ ì˜¤ë Œì§€, ê³¨ë“œ ë¸Œë¼ìš´ ë“±", value: 5 },
                { text: "ì• ì‰¬, ì¿¨ ë¸Œë¼ìš´, ë¸”ë™ ë“±", value: 1 }
            ],
            image: "ğŸ’‡â€â™€ï¸"
        }
    ];

    const results = {
        // 5 Questions (Min 5, Max 25)
        // 5-9: Winter / 10-14: Summer / 15-19: Autumn / 20-25: Spring
        'Spring': {
            name: "ë´„ ì›œ (Spring Warm) ğŸŒ¼",
            desc: "í™”ì‚¬í•˜ê³  ìƒê¸° ë°œë„í•œ ë§¤ë ¥! ë°ê³  ì±„ë„ ë†’ì€ ì˜ë¡œìš° ë² ì´ìŠ¤ ìƒ‰ìƒ, ì½”ë„, í”¼ì¹˜ í†¤ì´ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤. ê·€ì—¬ìš´ ëŠë‚Œì„ ê°•ì¡°í•´ ë³´ì„¸ìš”.",
            image: "ğŸŒ·",
            color: '#ffc6a9'
        },
        'Autumn': {
            name: "ê°€ì„ ì›œ (Autumn Warm) ğŸ‚",
            desc: "ì°¨ë¶„í•˜ê³  ê¹Šì´ ìˆëŠ” ìš°ì•„í•¨! ì±„ë„ê°€ ë‚®ê³  ë¶€ë“œëŸ¬ìš´ ë¸Œë¼ìš´, ì¹´í‚¤, ì˜¤ë Œì§€ ê³„ì—´ì´ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤. ë¶„ìœ„ê¸° ìˆëŠ” ë£©ì„ ì—°ì¶œí•´ ë³´ì„¸ìš”.",
            image: "ğŸ",
            color: '#c49a6d'
        },
        'Summer': {
            name: "ì—¬ë¦„ ì¿¨ (Summer Cool) â˜ï¸",
            desc: "ê¹¨ë—í•˜ê³  ì²­ëŸ‰í•œ ëŠë‚Œì˜ ì‹œì›í•¨! íŒŒìŠ¤í…”í†¤, íšŒìƒ‰ì´ ì„ì¸ ë¶€ë“œëŸ¬ìš´ ë¸”ë£¨/í•‘í¬ ê³„ì—´ì´ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤. ê¹”ë”í•˜ê³  ë‹¨ì•„í•œ ë§¤ë ¥ì„ ê°•ì¡°í•´ ë³´ì„¸ìš”.",
            image: "ğŸ§Š",
            color: '#b5d7e7'
        },
        'Winter': {
            name: "ê²¨ìš¸ ì¿¨ (Winter Cool) ğŸ’",
            desc: "ì‹œí¬í•˜ê³  ì„ ëª…í•œ ì¹´ë¦¬ìŠ¤ë§ˆ! ìˆœë°±ìƒ‰, ë¸”ë™, ë¹„ë¹„ë“œí•œ ë¸”ë£¨/ë§ˆì  íƒ€ ë“± ëŒ€ë¹„ê°ì´ ê°•í•œ ìƒ‰ìƒì´ ì˜ ì–´ìš¸ë¦½ë‹ˆë‹¤. ë„íšŒì ì¸ ë§¤ë ¥ì„ ë½ë‚´ì„¸ìš”.",
            image: "â„ï¸",
            color: '#848c9e'
        }
    };

    let buttonBounds = []; // ë²„íŠ¼ì˜ ê²½ê³„ë¥¼ ì €ì¥í•  ë°°ì—´

    // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---

    /**
     * ë‘¥ê·¼ ì‚¬ê°í˜•ì„ ê·¸ë¦½ë‹ˆë‹¤.
     */
    function drawRoundedRect(x, y, w, h, r, fillColor, strokeColor = null, shadow = null) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
        
        if (shadow) {
            ctx.shadowColor = shadow.color;
            ctx.shadowBlur = shadow.blur;
            ctx.shadowOffsetX = shadow.offsetX;
            ctx.shadowOffsetY = shadow.offsetY;
        } else {
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        if (fillColor) {
            ctx.fillStyle = fillColor;
            ctx.fill();
        }
        if (strokeColor) {
            ctx.strokeStyle = strokeColor;
            ctx.stroke();
        }
    }

    /**
     * ìº”ë²„ìŠ¤ì— í…ìŠ¤íŠ¸ë¥¼ ì¤„ ë°”ê¿ˆí•˜ì—¬ ê·¸ë¦½ë‹ˆë‹¤.
     */
    function wrapText(text, x, y, maxWidth, lineHeight, font) {
        ctx.font = font;
        ctx.textAlign = 'center';
        
        let words = text.split(' ');
        let line = '';
        let lineY = y;

        for (let n = 0; n < words.length; n++) {
            let testLine = line + words[n] + ' ';
            let metrics = ctx.measureText(testLine);
            let testWidth = metrics.width;

            if (testWidth > maxWidth && n > 0) {
                ctx.fillText(line, x, lineY);
                line = words[n] + ' ';
                lineY += lineHeight;
            } else {
                line = testLine;
            }
        }
        ctx.fillText(line, x, lineY);
        return lineY; // ë§ˆì§€ë§‰ ì¤„ì˜ Yì¢Œí‘œ ë°˜í™˜
    }

    // --- í€´ì¦ˆ ë¡œì§ ---

    function startQuiz() {
        currentQuestionIndex = 0;
        warmScore = 0;
        isQuizActive = true;
        drawScene();
    }

    function selectOption(value) {
        if (!isQuizActive) return;

        warmScore += value;
        currentQuestionIndex++;
        
        if (currentQuestionIndex < questions.length) {
            drawScene();
        } else {
            showResult();
        }
    }

    function showResult() {
        isQuizActive = false;
        drawScene();
    }

    function getResultKey() {
        // 5 Questions (Min 5, Max 25)
        if (warmScore >= 20) return 'Spring';
        if (warmScore >= 15) return 'Autumn';
        if (warmScore >= 10) return 'Summer';
        return 'Winter'; // 5-9ì 
    }

    // --- ê·¸ë¦¬ê¸° í•¨ìˆ˜ ---

    /**
     * ì „ì²´ í™”ë©´ì„ ì§€ìš°ê³  ê¸°ë³¸ ë°°ê²½ì„ ê·¸ë¦½ë‹ˆë‹¤.
     */
    function clearCanvas() {
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        drawRoundedRect(0, 0, canvasWidth, canvasHeight, 25 * scaleFactor, '#ffffff'); // ì»¨í…Œì´ë„ˆ ë°°ê²½ìƒ‰
    }

    /**
     * ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ì¡°ì •í•˜ê³  DPIì— ë§ì¶¥ë‹ˆë‹¤.
     */
    function resizeCanvas() {
        const container = canvas.parentElement;
        canvasWidth = container.clientWidth;
        canvasHeight = container.clientHeight;

        // ê³ í•´ìƒë„(DPI) ì¡°ì •
        canvas.width = canvasWidth * dpi;
        canvas.height = canvasHeight * dpi;
        ctx.scale(dpi, dpi);
        
        scaleFactor = canvasWidth / 500; // 500px ê¸°ì¤€ì˜ ìŠ¤ì¼€ì¼ íŒ©í„°
        
        drawScene();
    }
    
    /**
     * ì§ˆë¬¸ í™”ë©´ì„ ê·¸ë¦½ë‹ˆë‹¤.
     */
    function drawQuestion(qData, index) {
        buttonBounds = [];
        const paddingX = 40 * scaleFactor;
        const buttonHeight = 60 * scaleFactor;
        const buttonSpacing = 15 * scaleFactor;
        const imageSize = 100 * scaleFactor;
        const centerX = canvasWidth / 2;
        let currentY = 50 * scaleFactor;

        // 1. íƒ€ì´í‹€
        ctx.fillStyle = colors.primary;
        ctx.font = `${30 * scaleFactor}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText("í¼ìŠ¤ë„ ì»¬ëŸ¬ ì°¾ê¸° ğŸ’–", centerX, currentY);
        currentY += 50 * scaleFactor;

        // 2. ì´ë¯¸ì§€/ì•„ì´ì½˜ ë°•ìŠ¤
        const imageBoxY = currentY;
        drawRoundedRect(
            centerX - (imageSize * 1.5) / 2, 
            imageBoxY, 
            imageSize * 1.5, 
            imageSize, 
            15 * scaleFactor, 
            colors.secondary
        );
        ctx.fillStyle = colors.buttonText;
        ctx.font = `${60 * scaleFactor}px Arial`;
        ctx.fillText(qData.image, centerX, imageBoxY + imageSize * 0.7);
        currentY += imageSize + 30 * scaleFactor;

        // 3. ì§ˆë¬¸ í…ìŠ¤íŠ¸
        ctx.fillStyle = colors.textColor;
        ctx.font = `bold ${18 * scaleFactor}px Arial`;
        const questionText = `${index + 1}. ${qData.q}`;
        
        // í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ì²˜ë¦¬ ë° Y ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        currentY = wrapText(questionText, centerX, currentY, canvasWidth - paddingX * 2, 25 * scaleFactor, ctx.font);
        currentY += 40 * scaleFactor;

        // 4. ì„ íƒì§€ ë²„íŠ¼
        const buttonWidth = canvasWidth - paddingX * 2;
        
        qData.options.forEach((option, i) => {
            const buttonY = currentY;
            const isHovered = (
                mouseX > centerX - buttonWidth / 2 &&
                mouseX < centerX + buttonWidth / 2 &&
                mouseY > buttonY &&
                mouseY < buttonY + buttonHeight
            );

            const fillColor = isHovered ? colors.buttonHover : colors.buttonNormal;
            
            // ë²„íŠ¼ ë°°ê²½ (ë‘¥ê·¼ ì‚¬ê°í˜•)
            drawRoundedRect(
                centerX - buttonWidth / 2, 
                buttonY, 
                buttonWidth, 
                buttonHeight, 
                10 * scaleFactor, 
                fillColor,
                null, // No stroke
                { color: colors.shadow, blur: 10, offsetX: 0, offsetY: 5 * scaleFactor }
            );

            // ë²„íŠ¼ í…ìŠ¤íŠ¸
            ctx.fillStyle = colors.buttonText;
            ctx.font = `${16 * scaleFactor}px Arial`;
            ctx.fillText(option.text, centerX, buttonY + buttonHeight / 2 + 5 * scaleFactor);

            // ê²½ê³„ ì €ì¥
            buttonBounds.push({
                x: centerX - buttonWidth / 2,
                y: buttonY,
                w: buttonWidth,
                h: buttonHeight,
                value: option.value
            });

            currentY += buttonHeight + buttonSpacing;
        });
    }

    /**
     * ê²°ê³¼ í™”ë©´ì„ ê·¸ë¦½ë‹ˆë‹¤.
     */
    function drawResult() {
        buttonBounds = [];
        const result = results[getResultKey()];
        const centerX = canvasWidth / 2;
        let currentY = 50 * scaleFactor;
        const paddingX = 40 * scaleFactor;

        // 1. íƒ€ì´í‹€
        ctx.fillStyle = colors.primary;
        ctx.font = `bold ${30 * scaleFactor}px Arial`;
        ctx.fillText("ê²°ê³¼ê°€ ë‚˜ì™”ì–´ìš”! ğŸ‰", centerX, currentY);
        currentY += 50 * scaleFactor;

        // 2. ê²°ê³¼ ì´ë¯¸ì§€/ì•„ì´ì½˜
        const imageSize = 120 * scaleFactor;
        drawRoundedRect(
            centerX - imageSize / 2, 
            currentY, 
            imageSize, 
            imageSize, 
            15 * scaleFactor, 
            result.color, // ê²°ê³¼ì— ë”°ë¥¸ ìƒ‰ìƒ
            null,
            { color: colors.shadow, blur: 15, offsetX: 0, offsetY: 7 * scaleFactor }
        );
        ctx.fillStyle = '#ffffff';
        ctx.font = `${80 * scaleFactor}px Arial`;
        ctx.fillText(result.image, centerX, currentY + imageSize * 0.75);
        currentY += imageSize + 30 * scaleFactor;


        // 3. ìµœì¢… ì»¬ëŸ¬ ì´ë¦„
        ctx.fillStyle = result.color;
        ctx.font = `bold ${24 * scaleFactor}px Arial`;
        currentY = wrapText(result.name, centerX, currentY, canvasWidth - paddingX * 2, 30 * scaleFactor, ctx.font);
        currentY += 30 * scaleFactor;

        // 4. ì„¤ëª… í…ìŠ¤íŠ¸
        ctx.fillStyle = colors.textColor;
        ctx.font = `${16 * scaleFactor}px Arial`;
        currentY = wrapText(result.desc, centerX, currentY, canvasWidth - paddingX * 2, 24 * scaleFactor, ctx.font);
        currentY += 50 * scaleFactor;

        // 5. ë‹¤ì‹œ ì‹œì‘ ë²„íŠ¼
        const buttonWidth = canvasWidth * 0.6;
        const buttonHeight = 50 * scaleFactor;
        const buttonY = currentY;

        const isHovered = (
            mouseX > centerX - buttonWidth / 2 &&
            mouseX < centerX + buttonWidth / 2 &&
            mouseY > buttonY &&
            mouseY < buttonY + buttonHeight
        );

        const fillColor = isHovered ? colors.buttonHover : colors.secondary;
        
        drawRoundedRect(
            centerX - buttonWidth / 2, 
            buttonY, 
            buttonWidth, 
            buttonHeight, 
            10 * scaleFactor, 
            fillColor,
            null,
            { color: colors.shadow, blur: 10, offsetX: 0, offsetY: 5 * scaleFactor }
        );

        ctx.fillStyle = colors.buttonText;
        ctx.font = `bold ${16 * scaleFactor}px Arial`;
        ctx.fillText("ë‹¤ì‹œ í…ŒìŠ¤íŠ¸í•˜ê¸°", centerX, buttonY + buttonHeight / 2 + 5 * scaleFactor);

        // ê²½ê³„ ì €ì¥
        buttonBounds.push({
            x: centerX - buttonWidth / 2,
            y: buttonY,
            w: buttonWidth,
            h: buttonHeight,
            action: 'restart'
        });
    }

    /**
     * ë©”ì¸ ì”¬ ë“œë¡œì‰ í•¨ìˆ˜
     */
    function drawScene() {
        clearCanvas();

        if (isQuizActive) {
            const qData = questions[currentQuestionIndex];
            if (qData) {
                drawQuestion(qData, currentQuestionIndex);
            } else {
                showResult(); // í˜¹ì‹œ ëª¨ë¥¼ ì—ëŸ¬ ë°©ì§€
            }
        } else {
            drawResult();
        }
    }

    // --- ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---

    // ë§ˆìš°ìŠ¤ ì´ë™ ê°ì§€ (í˜¸ë²„ íš¨ê³¼)
    canvas.onmousemove = (event) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = event.clientX - rect.left;
        mouseY = event.clientY - rect.top;
        drawScene(); // í˜¸ë²„ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ê¸° ìœ„í•´ ë‹¤ì‹œ ê·¸ë¦½ë‹ˆë‹¤.
    };

    // ë§ˆìš°ìŠ¤ í´ë¦­ ê°ì§€ (ë²„íŠ¼ ìƒí˜¸ì‘ìš©)
    canvas.onclick = (event) => {
        const rect = canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;

        // í´ë¦­ëœ ë²„íŠ¼ ì°¾ê¸°
        for (const bound of buttonBounds) {
            if (
                clickX > bound.x &&
                clickX < bound.x + bound.w &&
                clickY > bound.y &&
                clickY < bound.y + bound.h
            ) {
                if (bound.action === 'restart') {
                    startQuiz();
                } else {
                    selectOption(bound.value);
                }
                return;
            }
        }
    };
    
    // ìœˆë„ìš° ë¡œë“œ ë° ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸
    window.onload = resizeCanvas;
    window.onresize = resizeCanvas;

    // ì´ˆê¸° ì‹œì‘
    // resizeCanvas í˜¸ì¶œë¡œ ì¸í•´ startQuizê°€ ê°„ì ‘ì ìœ¼ë¡œ ì‹¤í–‰ë¨
</script>

</body>
</html>
